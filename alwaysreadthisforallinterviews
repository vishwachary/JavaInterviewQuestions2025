Java Performance Interview Prep â€“ Real Scenarios with Fixes

In senior interviews, youâ€™re often asked to debug performance bottlenecks in real-world systems.
Hereâ€™s a set of 5 practical scenarios with examples + solutions ğŸ‘‡


ğŸ”¹ Scenario 1 â€“ Slow SQL Queries
âŒ Problem: Dashboard takes 10s to load due to full table scans.

-- Bad: full scan on large table
SELECT * FROM transactions WHERE user_id = 123;

âœ… Fix: Add an index + fetch only required columns with pagination.

CREATE INDEX idx_user_id ON transactions(user_id);

SELECT txn_id, amount, status 
FROM transactions 
WHERE user_id = 123 LIMIT 20 OFFSET 0;

ğŸ“Œ Impact: Query response time reduced from 10s â†’ <100ms.



ğŸ”¹ Scenario 2 â€“ Memory Leak in Microservice
âŒ Problem: Service crashes with OutOfMemoryError after 5 hours. Heap dump shows open file handles.

// Bad: never closed
BufferedReader br = new BufferedReader(new FileReader("data.txt"));
String line = br.readLine();

âœ… Fix: Use try-with-resources to auto-close streams.

try (BufferedReader br = new BufferedReader(new FileReader("data.txt"))) {
 String line = br.readLine();
}

ğŸ“Œ Impact: No memory leaks â†’ stable uptime.



ğŸ”¹ Scenario 3 â€“ High Latency in API
âŒ Problem: Checkout API takes 3s during peak load.
Cause: sequential DB + service calls.

// Bad: sequential
User user = userService.getUser(id);
Orders orders = orderService.getOrders(id);

âœ… Fix: Use CompletableFuture to parallelize.

CompletableFuture<User> user = supplyAsync(() -> userService.getUser(id));
CompletableFuture<Orders> orders = supplyAsync(() -> orderService.getOrders(id));
CompletableFuture.allOf(user, orders).join();

ğŸ“Œ Impact: Latency reduced 3s â†’ ~1.2s under load.



ğŸ”¹ Scenario 4 â€“ GC (Garbage Collection) Pauses
âŒ Problem: High CPU + GC logs show frequent Full GCs.
Cause: too many short-lived objects.

âœ… Fix:

Use object pooling for frequently used objects.

Switch from Parallel GC â†’ G1GC for lower pause times.


-XX:+UseG1GC -XX:MaxGCPauseMillis=200

ğŸ“Œ Impact: Pause time reduced 800ms â†’ <150ms.



ğŸ”¹ Scenario 5 â€“ N+1 Query Problem
âŒ Problem: Fetching users with orders â†’ 1 query for users + 1 query per user (total 1001 queries).

// Bad: N+1 issue
List<User> users = userRepo.findAll();
for (User u : users) {
 u.getOrders().size(); // triggers extra query per user
}

âœ… Fix: Use JOIN FETCH or batch fetching.

@Query("SELECT u FROM User u JOIN FETCH u.orders")
List<User> findAllWithOrders();

ğŸ“Œ Impact: Reduced DB calls 1001 â†’ 1.



ğŸ’¡ Interview Tip
Always answer in 3 steps:
1ï¸âƒ£ How you detected the issue (profilers, heap dump, slow query log, metrics).
2ï¸âƒ£ Root cause (bad query, GC, memory leak).
3ï¸âƒ£ Fix + measurable impact (before vs after).

